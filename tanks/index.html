<!-- Licensed under a BSD license. See license.html for license -->
<!DOCTYPE html>
<html>
<head>
<title>Tanks!</title>
<style>
    body {
        margin: 0px auto;
        background-color:rgb(0,0,0);
        color:rgb(255,255,255);
        text-align:center;
        border: 0;
        overflow: hidden; /*  Disable scrollbars */
        display: block;  /* No floating content on sides */
    }
    canvas {
        position:absolute;
        top:0;
        left:0;
        width:100%;
        height:100%;
        z-index:-1;
    }
    .overlay {
        position: absolute;
        margin-left: 89%;
        float: right;
        width: 10%;
        background-color: rgba(0,0,0,0.65);
    }
</style>
<script src="resources/jquery-1.7.1.min.js"></script>
<script src="resources/webgl-utils.js"></script>
<script src="helpers/helpers.js"></script>
<script src="helpers/objectHelpers.js"></script>
<script src="helpers/animation.js"></script>
<script src="helpers/keys.js"></script>
<script src="helpers/references.js"></script>
    
<script src="utils/matrix.js"></script>   

<script src="objects/Skybox.js"></script>
<script src="objects/Terrain.js"></script>
<script src="objects/Sherman.js"></script>
<script src="objects/Hetzer.js"></script>
<script src="objects/KVTwo.js"></script>
<script src="objects/ATEight.js"></script>
<script src="objects/TEighteen.js"></script>
<script src="objects/ELC.js"></script>
<script src="objects/BatChatillion.js"></script>

<script src="objects/ShermanTurret.js"></script>
<script src="objects/KVTwoTurret.js"></script>
<script src="objects/ELCTurret.js"></script>
<script src="objects/BatChatillionTurret.js"></script>

<script src="objects/Barrel.js"></script>
<script src="objects/Hangar.js"></script>
    
<script>
"use strict";

$(function(){
    main();
});

var helpers = new Helpers();
var cameraZ = 30;
var cameraHeight = 8;
var cameraAngleRadians = degToRad(180);

var skybox = new Skybox(0,0,0);
var objects = [
    new Terrain(),

    new Sherman(),
    new Hetzer(),
    new KVTwo(),
    new ATEight(),
    new TEighteen(),
    new ELC(),
    new BatChatillion(),

    new Hangar(),
    new Hangar(),
    new Hangar(),
    new Hangar(),
    new Hangar(),
    new Hangar(),
    new Hangar(),

    new Barrel(),
    new Barrel(),
    new Barrel(),
    new Barrel(),
    new Barrel(),
    new Barrel(),
    new Barrel()
];
var children = [
    new ShermanTurret(),
    new KVTwoTurret(),
    new ELCTurret(),
    new BatChatillionTurret()
];

function main() {
    // Get A WebGL context
    var canvas = document.getElementById("canvas");
    
    // make the canvas fullscreen
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;

    window.onresize = function() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
    }
    
    var gl = getWebGLContext(canvas);
    if (!gl) {
    return;
    }

    gl.enable(gl.CULL_FACE);
    gl.enable(gl.DEPTH_TEST);

    // setup GLSL program
    var program = createProgramFromScripts(gl, ["3d-vertex-shader", "3d-fragment-shader"]);
    gl.useProgram(program);

    // look up where the vertex data needs to go.
    var positionLocation = gl.getAttribLocation(program, "a_position");
    var colorLocation = gl.getAttribLocation(program, "a_color");

    // lookup uniforms
    var matrixLocation = gl.getUniformLocation(program, "u_matrix");
    
    function initScene()
    { 
        // Set Geometry and colors
        skybox.setGeometry(gl);
        skybox.setColors(gl);
        objects.forEach(function(object)
        {
            object.setGeometry(gl);
            object.setColors(gl);
        });
        children.forEach(function(childObject)
        {
            childObject.setGeometry(gl);
            childObject.setColors(gl);
        });
    }

    var fieldOfViewRadians = degToRad(60);
    

    initScene();
    
    document.onkeydown = handleKeyDown;
    document.onkeyup = handleKeyUp;

    setOrigionalPositionsAndRotation();
    tick();
    
    function tick() 
    {
        requestAnimFrame(tick);
        handleKeys();
        drawScene(objects, children);
    }
    
    // Draw the scene.
    function drawScene(objects, children) 
    {
        // Clear the canvas AND the depth buffer.
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

        // Compute the projection matrix
        var aspect = canvas.clientWidth / canvas.clientHeight;
        var projectionMatrix =
            makePerspective(fieldOfViewRadians, aspect, 1, 2000);

        // Compute the position of the first F
        // camera always rotates around the origin F.position = 0, 0, 0

        // Use matrix math to compute a position on the circle.
        var cameraMatrix = makeTranslation(0, cameraHeight, cameraZ);
        cameraMatrix = matrixMultiply(
            cameraMatrix, makeYRotation(cameraAngleRadians));


        // Get the camera's postion from the matrix we computed
        var cameraPosition = [
            cameraMatrix[12],
            cameraMatrix[13],
            cameraMatrix[14]];

        var up = [0, 1, 0];

        // Compute the camera's matrix using look at.
        var cameraMatrix = makeLookAt(cameraPosition, objects[FOCUS].position, up);

        // Make a view matrix from the camera matrix.
        var viewMatrix = makeInverse(cameraMatrix);

        // center the skybox around the camera and send the walls of the box to the background
        skybox.position = cameraPosition;
        draw(skybox, cameraMatrix, viewMatrix, projectionMatrix);
        gl.clear(gl.DEPTH_BUFFER_BIT); // send the skybox to the background

        objects.forEach(function(object)
        {
            draw(object, cameraMatrix, viewMatrix, projectionMatrix);
        });
        children.forEach(function(childObject)
        {
            draw(childObject, cameraMatrix, viewMatrix, projectionMatrix);
        });
    }
    
    function draw(object, cameraMatrix, viewMatrix, projectionMatrix)
    {    
        // setup the translation of the object
        var translationMatrix = makeTranslation(object.position[X], object.position[Y], object.position[Z]);

        var rotationYMatrix = makeYRotation(object.rotation[Y]);
        
        // Multiply the matrices.
        var matrix = rotationYMatrix;
        matrix = matrixMultiply(matrix, translationMatrix);
        matrix = matrixMultiply(matrix, viewMatrix);
        matrix = matrixMultiply(matrix, projectionMatrix);

        // Set the matrix.
        gl.uniformMatrix4fv(matrixLocation, false, matrix);

        // Create a buffer.
        gl.bindBuffer(gl.ARRAY_BUFFER, object.vbo);
        gl.enableVertexAttribArray(positionLocation);
        gl.vertexAttribPointer(positionLocation, object.vbo.itemSize, gl.FLOAT, false, 0, 0);

        // Create a buffer for colors.
        gl.bindBuffer(gl.ARRAY_BUFFER, object.cbo);
        gl.enableVertexAttribArray(colorLocation);

        // We'll supply RGB as bytes.
        gl.vertexAttribPointer(colorLocation, object.cbo.itemSize, gl.UNSIGNED_BYTE, true, 0, 0); 

        // Draw the geometry.
        gl.drawArrays(gl.TRIANGLES, 0, object.vbo.numItems);
    }
}

</script>
   
    
    
    
<!-- vertex shader -->
<script id="3d-vertex-shader" type="x-shader/x-vertex">
attribute vec4 a_position;
attribute vec4 a_color;

uniform mat4 u_matrix;

varying vec4 v_color;

void main() {
  // Multiply the position by the matrix.
  gl_Position = u_matrix * a_position;

  // Pass the color to the fragment shader.
  v_color = a_color;
}
</script>
    
<!-- fragment shader -->
<script id="3d-fragment-shader" type="x-shader/x-fragment">
precision mediump float;

// Passed in from the vertex shader.
varying vec4 v_color;

void main() {
   gl_FragColor = v_color;
}
</script>
    
    
</head>
    
<body>
    <canvas id="canvas" width="400" height="300"></canvas>
        <div class="overlay">
            <!--
            <div id="cameraAngle"></div>
            <div id="cameraHeight"></div>
            -->
        </div>
</body>

</html>


